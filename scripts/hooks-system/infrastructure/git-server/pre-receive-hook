#!/usr/bin/env bash
# =============================================================================
# Server-Side Pre-Receive Hook (GitHub Enterprise / Self-hosted Git)
# =============================================================================
# Purpose: Validate commits on server BEFORE accepting push
# Cannot be bypassed - runs on server side
# Author: Pumuki Team®
# Version: 1.0.0
# =============================================================================
# Installation:
#   1. For GitHub Enterprise: Configure as pre-receive hook in repository settings
#   2. For Self-hosted Git: Copy to hooks/pre-receive on bare repository
#   3. Make executable: chmod +x pre-receive-hook
# =============================================================================

set -euo pipefail

# Read stdin (format: <old-value> <new-value> <ref-name>)
while read oldrev newrev refname; do
  # Extract branch name
  branch=$(echo "$refname" | sed 's/refs\/heads\///')

  echo "[SERVER] Validating push to: $branch"

  # =============================================================================
  # 1. PREVENT DIRECT PUSH TO MAIN
  # =============================================================================
  if [ "$branch" = "main" ]; then
    echo "❌ [SERVER] Direct push to main is FORBIDDEN"
    echo "   → Use Pull Request workflow instead"
    echo "   → Push to feature/fix branch and create PR"
    exit 1
  fi

  # =============================================================================
  # 2. PREVENT FORCE PUSH TO PROTECTED BRANCHES
  # =============================================================================
  if [ "$branch" = "develop" ] || [ "$branch" = "main" ]; then
    # Check if this is a force push
    if git rev-list "$newrev" "^$oldrev" > /dev/null 2>&1; then
      : # Normal push, OK
    else
      echo "❌ [SERVER] Force push to $branch is FORBIDDEN"
      echo "   → Protected branches cannot be force-pushed"
      exit 1
    fi
  fi

  # =============================================================================
  # 3. VALIDATE BRANCH NAMING CONVENTION
  # =============================================================================
  if ! echo "$branch" | grep -qE '^(main|develop|feature/|fix/|hotfix/|release/)'; then
    echo "❌ [SERVER] Invalid branch name: $branch"
    echo "   → Must match: feature/*, fix/*, hotfix/*, release/*, develop, main"
    echo "   → Example: feature/user-authentication"
    exit 1
  fi

  # =============================================================================
  # 4. VALIDATE COMMIT MESSAGES
  # =============================================================================
  echo "[SERVER] Validating commit messages..."
  commits=$(git rev-list "$oldrev".."$newrev")
  invalid_count=0

  for commit in $commits; do
    msg=$(git log --format=%B -n 1 "$commit" | head -1)

    # Check conventional commit format: type(scope): description
    if ! echo "$msg" | grep -qE '^(feat|fix|docs|style|refactor|test|chore|perf|ci|build|revert)(\(.+\))?: .{10,}'; then
      echo "❌ [SERVER] Invalid commit message: $commit"
      echo "   Message: $msg"
      echo "   → Required format: type(scope): description"
      echo "   → Examples:"
      echo "      • feat(auth): add JWT authentication"
      echo "      • fix(api): resolve null pointer in users endpoint"
      echo "      • docs: update README with installation steps"
      invalid_count=$((invalid_count + 1))
    fi
  done

  if [ $invalid_count -gt 0 ]; then
    echo ""
    echo "❌ [SERVER] $invalid_count commit(s) have invalid messages"
    echo "   → Fix commit messages and try again"
    exit 1
  fi

  # =============================================================================
  # 5. CHECK FOR MERGE CONFLICT MARKERS
  # =============================================================================
  echo "[SERVER] Checking for conflict markers..."
  for commit in $commits; do
    if git diff-tree --no-commit-id --name-only -r "$commit" | xargs git show "$commit" -- | grep -qE '^(<<<<<<<|>>>>>>>|=======)'; then
      echo "❌ [SERVER] Merge conflict markers detected in commit: $commit"
      echo "   → Resolve conflicts before pushing"
      exit 1
    fi
  done

  # =============================================================================
  # 6. VALIDATE AI EVIDENCE (Enterprise Guard - mandatory)
  # =============================================================================
  echo "[SERVER] Validating AI evidence..."
  for commit in $commits; do
    commit_epoch=$(git show -s --format=%ct "$commit")
    evidence_blob=$(git show "$commit:.AI_EVIDENCE.json" 2>/dev/null || true)

    if [ -z "$evidence_blob" ]; then
      echo "❌ [SERVER] .AI_EVIDENCE.json missing in commit: $commit"
      echo "   → AI protocol evidence must be committed with every change"
      exit 1
    fi

    if ! echo "$evidence_blob" | python3 - "$commit" "$commit_epoch" <<'PY'
import sys
import json
from datetime import datetime, timezone

commit_hash = sys.argv[1]
commit_epoch = int(sys.argv[2])

errors = []

try:
    evidence = json.load(sys.stdin)
except json.JSONDecodeError as exc:
    print(f"Invalid JSON format ({exc})")
    sys.exit(1)

timestamp = evidence.get("timestamp")
if not timestamp or not isinstance(timestamp, str) or not timestamp.strip():
    errors.append("Missing timestamp in .AI_EVIDENCE.json")
else:
    try:
        dt = datetime.strptime(timestamp.strip(), "%Y-%m-%dT%H:%M:%SZ").replace(tzinfo=timezone.utc)
        diff_seconds = abs(commit_epoch - int(dt.timestamp()))
        if diff_seconds > 600:
            errors.append(f"Timestamp drift {diff_seconds}s exceeds 600s limit")
    except ValueError:
        errors.append(f"Invalid timestamp format: {timestamp}")

questions = evidence.get("protocol_3_questions") or {}
answered = questions.get("answered")

def is_placeholder(value):
    if value is None:
        return True
    text = str(value).strip()
    if not text:
        return True
    return text.lower().startswith("todo")

if answered is not True:
    errors.append("Protocol 3 questions not answered")

q1 = questions.get("question_1_file_type")
q2 = questions.get("question_2_similar_exists")
q3 = questions.get("question_3_clean_architecture")

if any(is_placeholder(val) for val in (q1, q2, q3)):
    errors.append("Protocol 3 questions contain placeholders or empty values")

justification = evidence.get("justification")
if is_placeholder(justification):
    errors.append("Justification is missing or marked as TODO")

rules_read = evidence.get("rules_read")
verified_rules = []
all_verified = True

if isinstance(rules_read, list):
    for entry in rules_read:
        if not isinstance(entry, dict):
            continue
        if entry.get("verified") is not True:
            all_verified = False
        file_name = entry.get("file")
        if file_name:
            verified_rules.append(file_name)
elif isinstance(rules_read, dict):
    if rules_read.get("verified") is not True:
        all_verified = False
    file_name = rules_read.get("file")
    if file_name:
        verified_rules.append(file_name)
else:
    errors.append("rules_read missing or invalid format")

if not verified_rules:
    errors.append("No rules recorded in rules_read")
elif not all_verified:
    errors.append("Some rules in rules_read are not marked as verified")

if errors:
    for err in errors:
        print(f"{commit_hash}: {err}")
    sys.exit(1)
PY
    then
      echo "❌ [SERVER] AI evidence validation failed for commit: $commit"
      exit 1
    fi
  done

  # =============================================================================
  # 7. CHECK FOR SECRETS / SENSITIVE DATA
  # =============================================================================
  echo "[SERVER] Scanning for hardcoded secrets..."
  for commit in $commits; do
    # Get files changed in commit
    files=$(git diff-tree --no-commit-id --name-only -r "$commit" | grep -E '\.(ts|js|tsx|jsx|py|java|kt|swift)$' || true)

    for file in $files; do
      if git show "$commit:$file" 2>/dev/null | grep -qiE '(password|api_key|secret|token|bearer)\s*[:=]\s*["\x27][^"\x27]{8,}["\x27]'; then
        echo "❌ [SERVER] Potential hardcoded secret detected"
        echo "   Commit: $commit"
        echo "   File: $file"
        echo "   → Remove sensitive data and use environment variables"
        exit 1
      fi
    done
  done

  # =============================================================================
  # 8. VALIDATE FILE SIZE LIMITS
  # =============================================================================
  echo "[SERVER] Checking file sizes..."
  for commit in $commits; do
    # Get files changed with sizes
    large_files=$(git diff-tree --no-commit-id -r --diff-filter=ACMRT "$commit" | \
      awk '{print $4, $5}' | \
      while read size file; do
        if [ "$size" -gt 1048576 ]; then # 1MB
          echo "$file ($((size / 1024))KB)"
        fi
      done)

    if [ -n "$large_files" ]; then
      echo "⚠️  [SERVER] Large files detected in commit: $commit"
      echo "$large_files"
      echo "   → Consider using Git LFS for large files"
    fi
  done

  echo "[SERVER] ✅ All validations passed for branch: $branch"
done

# All validations passed
echo ""
echo "✅ [SERVER] Push accepted"
echo "   All commits validated successfully"
exit 0
