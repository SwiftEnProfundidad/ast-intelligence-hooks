const fs = require('fs');
const path = require('path');
const { execSync, spawnSync } = require('child_process');

const COLORS = {
    reset: '\x1b[0m',
    blue: '\x1b[34m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    red: '\x1b[31m',
    cyan: '\x1b[36m'
};

class GitEnvironmentService {
    constructor(targetRoot) {
        this.targetRoot = targetRoot || process.cwd();
    }

    checkGitRepository() {
        const gitDir = path.join(this.targetRoot, '.git');
        if (!fs.existsSync(gitDir)) {
            this.logError('‚ùå CRITICAL: Git repository not found!');
            this.logWarning('   This library REQUIRES a Git repository to function properly.');
            this.logInfo('   Please run: git init\n');
            this.logWarning('‚ö†Ô∏è  Without Git:');
            this.logInfo('   ‚Ä¢ Pre-commit hooks cannot be installed');
            this.logInfo('   ‚Ä¢ Git Flow automation will not work');
            this.logInfo('   ‚Ä¢ Code analysis on commits is disabled\n');
            return false;
        }

        try {
            execSync('git rev-parse --show-toplevel', {
                cwd: this.targetRoot,
                stdio: 'ignore'
            });
            return true;
        } catch (err) {
            this.logError('‚ùå Git repository is not properly initialized!');
            this.logWarning('   Found .git directory but git commands fail.');
            this.logInfo('   Please ensure Git is installed and working.\n');
            return false;
        }
    }

    ensureGitInfoExclude() {
        const gitDir = path.join(this.targetRoot, '.git');
        if (!fs.existsSync(gitDir)) return;

        const excludePath = path.join(gitDir, 'info', 'exclude');
        fs.mkdirSync(path.dirname(excludePath), { recursive: true });

        const header = '# AST Intelligence Hooks (generated artifacts)';
        const patterns = [
            '.AI_TOKEN_STATUS.txt',
            '.audit-reports/*.log',
            '.realtime-guard.pid',
            '.token-monitor-guard.pid'
        ];

        let existing = '';
        if (fs.existsSync(excludePath)) {
            existing = fs.readFileSync(excludePath, 'utf8');
            if (existing.includes(header)) return;
        }

        const block = '\n' + header + '\n' + patterns.join('\n') + '\n';
        fs.appendFileSync(excludePath, block);
        this.logSuccess('  ‚úÖ Added artifact patterns to .git/info/exclude');
    }

    installGitHooks() {
        const gitHooksDir = path.join(this.targetRoot, '.git/hooks');

        if (!fs.existsSync(gitHooksDir)) {
            this.logError('‚úó .git/hooks directory not found');
            this.logWarning('  Git hooks cannot be installed without a valid Git repository.');
            return;
        }

        const preCommitHook = this.getPreCommitHookContent();
        const preCommitPath = path.join(gitHooksDir, 'pre-commit');

        fs.writeFileSync(preCommitPath, preCommitHook);
        fs.chmodSync(preCommitPath, '755');
        this.logSuccess('  ‚úÖ Installed pre-commit hook');
    }

    getPreCommitHookContent() {
        return `#!/bin/bash
# AST Intelligence Hooks - Pre-commit
# Auto-generated by @pumuki/ast-intelligence-hooks v5.3.1

# Check for bypass
if [[ -n "\${GIT_BYPASS_HOOK}" ]]; then
  echo "‚ö†Ô∏è  Bypassing AST hooks (GIT_BYPASS_HOOK=1)"
  exit 0
fi

# Change to project root (where package.json is)
cd "$(git rev-parse --show-toplevel)" || exit 1

# Check if there are staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM 2>/dev/null | grep -E '\\.(ts|tsx|js|jsx|swift|kt)$' || true)
if [ -z "$STAGED_FILES" ]; then
  # No staged files to analyze, allow commit
  exit 0
fi

# Try node_modules/.bin first (works with npm install)
if [ -f "node_modules/.bin/ast-hooks" ]; then
  OUTPUT=$(node_modules/.bin/ast-hooks ast 2>&1)
  EXIT_CODE=$?
  echo "$OUTPUT"
  if [ $EXIT_CODE -ne 0 ]; then
    exit $EXIT_CODE
  fi
  if echo "$OUTPUT" | grep -qE "CRITICAL|HIGH"; then
    echo ""
    echo "‚ùå Commit blocked: Critical or High violations detected in staged files"
    
    # Simple extraction of violation counts for notification
    TOTAL_VIOLATIONS=$(echo "$OUTPUT" | grep -oE "CRITICAL=[0-9]+" | cut -d= -f2)
    if [ -z "$TOTAL_VIOLATIONS" ]; then TOTAL_VIOLATIONS=1; fi
    
    osascript -e "display notification \\"Commit blocked by violations\\" with title \\"üö´ Commit Blocked\\" sound name \\"Basso\\"" 2>/dev/null || true
    
    exit 1
  fi
  # Copy ast-summary.json to root if it exists
  if [ -f ".audit_tmp/ast-summary.json" ]; then
    cp .audit_tmp/ast-summary.json ast-summary.json 2>/dev/null || true
  fi
  exit 0
fi

# Fallback: direct execution logic here...
echo "‚ö†Ô∏è  ast-intelligence-hooks not found"
exit 0
`;
    }

    logInfo(msg) { process.stdout.write(`${COLORS.cyan}${msg}${COLORS.reset}\n`); }
    logSuccess(msg) { process.stdout.write(`${COLORS.green}${msg}${COLORS.reset}\n`); }
    logWarning(msg) { process.stdout.write(`${COLORS.yellow}${msg}${COLORS.reset}\n`); }
    logError(msg) { process.stdout.write(`${COLORS.red}${msg}${COLORS.reset}\n`); }
}

module.exports = GitEnvironmentService;
