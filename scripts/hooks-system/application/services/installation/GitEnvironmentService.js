const fs = require('fs');
const path = require('path');
const { execSync, spawnSync } = require('child_process');

const COLORS = {
  reset: '\x1b[0m',
  blue: '\x1b[34m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  red: '\x1b[31m',
  cyan: '\x1b[36m'
};

class GitEnvironmentService {
  constructor(targetRoot, version = 'unknown') {
    this.targetRoot = targetRoot || process.cwd();
    this.version = version;
  }

  checkGitRepository() {
    const gitDir = path.join(this.targetRoot, '.git');
    if (!fs.existsSync(gitDir)) {
      this.logError('‚ùå CRITICAL: Git repository not found!');
      this.logWarning('   This library REQUIRES a Git repository to function properly.');
      this.logInfo('   Please run: git init\n');
      this.logWarning('‚ö†Ô∏è  Without Git:');
      this.logInfo('   ‚Ä¢ Pre-commit hooks cannot be installed');
      this.logInfo('   ‚Ä¢ Git Flow automation will not work');
      this.logInfo('   ‚Ä¢ Code analysis on commits is disabled\n');
      return false;
    }

    try {
      execSync('git rev-parse --show-toplevel', {
        cwd: this.targetRoot,
        stdio: 'ignore'
      });
      return true;
    } catch (err) {
      this.logError('‚ùå Git repository is not properly initialized!');
      this.logWarning('   Found .git directory but git commands fail.');
      this.logInfo('   Please ensure Git is installed and working.\n');
      return false;
    }
  }

  ensureGitInfoExclude() {
    const gitDir = path.join(this.targetRoot, '.git');
    if (!fs.existsSync(gitDir)) return;

    const excludePath = path.join(gitDir, 'info', 'exclude');
    fs.mkdirSync(path.dirname(excludePath), { recursive: true });

    const header = '# AST Intelligence Hooks (generated artifacts)';
    const patterns = [
      '.AI_TOKEN_STATUS.txt',
      '.audit-reports/*.log',
      '.realtime-guard.pid',
      '.token-monitor-guard.pid'
    ];

    let existing = '';
    if (fs.existsSync(excludePath)) {
      existing = fs.readFileSync(excludePath, 'utf8');
      if (existing.includes(header)) return;
    }

    const block = '\n' + header + '\n' + patterns.join('\n') + '\n';
    fs.appendFileSync(excludePath, block);
    this.logSuccess('  ‚úÖ Added artifact patterns to .git/info/exclude');
  }

  installGitHooks() {
    const gitHooksDir = path.join(this.targetRoot, '.git/hooks');

    if (!fs.existsSync(gitHooksDir)) {
      this.logError('‚úó .git/hooks directory not found');
      this.logWarning('  Git hooks cannot be installed without a valid Git repository.');
      return;
    }

    const preCommitHook = this.getPreCommitHookContent();
    const preCommitPath = path.join(gitHooksDir, 'pre-commit');

    fs.writeFileSync(preCommitPath, preCommitHook);
    fs.chmodSync(preCommitPath, '755');
    this.logSuccess('  ‚úÖ Installed pre-commit hook');
  }

  getPreCommitHookContent() {
    return `#!/bin/bash
# AST Intelligence Hooks - Pre-commit
# Auto-generated by pumuki-ast-hooks v${this.version}

# Check for bypass
if [[ -n "\${GIT_BYPASS_HOOK}" ]]; then
  echo "‚ö†Ô∏è  Bypassing AST hooks (GIT_BYPASS_HOOK=1)"
  exit 0
fi

# Change to project root (where package.json is)
cd "$(git rev-parse --show-toplevel)" || exit 1

# Check if there are staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM 2>/dev/null | grep -E '\\.(ts|tsx|js|jsx|swift|kt)$' || true)
if [ -z "$STAGED_FILES" ]; then
  # No staged files to analyze, allow commit
  exit 0
fi

# Try node_modules/.bin first (works with npm install)
if [ -f "node_modules/.bin/ast-hooks" ]; then
  OUTPUT=$(node_modules/.bin/ast-hooks ast --staged 2>&1)
  EXIT_CODE=$?
  echo "$OUTPUT"
  if [ $EXIT_CODE -ne 0 ]; then
    exit $EXIT_CODE
  fi
  # Block commits only when there are actual CRITICAL/HIGH violations.
  # Do NOT block on summary lines like: "CRITICAL=0 HIGH=0".
  if echo "$OUTPUT" | grep -qE "CRITICAL=[1-9]|HIGH=[1-9]|\[CRITICAL\]|\[HIGH\]"; then
    echo ""
    echo "‚ùå Commit blocked: Critical or High violations detected in staged files"
    
    # Extract counts (best-effort) for notification.
    # Prefer explicit totals (CRITICAL=, HIGH=) and fallback to tag counts.
    CRITICAL_COUNT=$(echo "$OUTPUT" | grep -oE "CRITICAL=[0-9]+" | head -1 | cut -d= -f2)
    HIGH_COUNT=$(echo "$OUTPUT" | grep -oE "HIGH=[0-9]+" | head -1 | cut -d= -f2)

    if [ -z "$CRITICAL_COUNT" ]; then
      CRITICAL_COUNT=$(echo "$OUTPUT" | grep -oE "\[CRITICAL\]" | wc -l | tr -d ' ')
    fi
    if [ -z "$HIGH_COUNT" ]; then
      HIGH_COUNT=$(echo "$OUTPUT" | grep -oE "\[HIGH\]" | wc -l | tr -d ' ')
    fi

    CRITICAL_COUNT=$(printf '%s' "$CRITICAL_COUNT" | tr -cd '0-9')
    HIGH_COUNT=$(printf '%s' "$HIGH_COUNT" | tr -cd '0-9')
    [ -z "$CRITICAL_COUNT" ] && CRITICAL_COUNT=0
    [ -z "$HIGH_COUNT" ] && HIGH_COUNT=0
    TOTAL_VIOLATIONS=$((CRITICAL_COUNT + HIGH_COUNT))
    [ "$TOTAL_VIOLATIONS" -le 0 ] && TOTAL_VIOLATIONS=1
    
    osascript -e "display notification \\"Commit blocked by violations\\" with title \\"üö´ Commit Blocked\\" sound name \\"Basso\\"" 2>/dev/null || true
    
    exit 1
  fi
  # Copy ast-summary.json to root if it exists
  if [ -f ".audit_tmp/ast-summary.json" ]; then
    cp .audit_tmp/ast-summary.json ast-summary.json 2>/dev/null || true
  fi
  exit 0
fi

# Fallback: direct execution logic here...
echo "‚ö†Ô∏è  ast-intelligence-hooks not found"
exit 0
`;
  }

  logInfo(msg) { process.stdout.write(`${COLORS.cyan}${msg}${COLORS.reset}\n`); }
  logSuccess(msg) { process.stdout.write(`${COLORS.green}${msg}${COLORS.reset}\n`); }
  logWarning(msg) { process.stdout.write(`${COLORS.yellow}${msg}${COLORS.reset}\n`); }
  logError(msg) { process.stdout.write(`${COLORS.red}${msg}${COLORS.reset}\n`); }
}

module.exports = GitEnvironmentService;
