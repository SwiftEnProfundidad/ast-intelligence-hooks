const fs = require('fs');
const path = require('path');
const { execSync, spawnSync } = require('child_process');

const COLORS = {
  reset: '\x1b[0m',
  blue: '\x1b[34m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  red: '\x1b[31m',
  cyan: '\x1b[36m'
};

class GitEnvironmentService {
  constructor(targetRoot, version = 'unknown') {
    this.targetRoot = targetRoot || process.cwd();
    this.version = version;
  }

  checkGitRepository() {
    const gitDir = path.join(this.targetRoot, '.git');
    if (!fs.existsSync(gitDir)) {
      this.logError('‚ùå CRITICAL: Git repository not found!');
      this.logWarning('   This library REQUIRES a Git repository to function properly.');
      this.logInfo('   Please run: git init\n');
      this.logWarning('‚ö†Ô∏è  Without Git:');
      this.logInfo('   ‚Ä¢ Pre-commit hooks cannot be installed');
      this.logInfo('   ‚Ä¢ Git Flow automation will not work');
      this.logInfo('   ‚Ä¢ Code analysis on commits is disabled\n');
      return false;
    }

    try {
      execSync('git rev-parse --show-toplevel', {
        cwd: this.targetRoot,
        stdio: 'ignore'
      });
      return true;
    } catch (err) {
      this.logError('‚ùå Git repository is not properly initialized!');
      this.logWarning('   Found .git directory but git commands fail.');
      this.logInfo('   Please ensure Git is installed and working.\n');
      return false;
    }
  }

  ensureGitInfoExclude() {
    const gitDir = path.join(this.targetRoot, '.git');
    if (!fs.existsSync(gitDir)) return;

    const excludePath = path.join(gitDir, 'info', 'exclude');
    fs.mkdirSync(path.dirname(excludePath), { recursive: true });

    const header = '# AST Intelligence Hooks (generated artifacts)';
    const patterns = [
      '.AI_TOKEN_STATUS.txt',
      '.audit-reports/*.log',
      '.realtime-guard.pid',
      '.token-monitor-guard.pid'
    ];

    let existing = '';
    if (fs.existsSync(excludePath)) {
      existing = fs.readFileSync(excludePath, 'utf8');
      if (existing.includes(header)) return;
    }

    const block = '\n' + header + '\n' + patterns.join('\n') + '\n';
    fs.appendFileSync(excludePath, block);
    this.logSuccess('  ‚úÖ Added artifact patterns to .git/info/exclude');
  }

  installGitHooks() {
    const gitHooksDir = path.join(this.targetRoot, '.git/hooks');

    if (!fs.existsSync(gitHooksDir)) {
      this.logError('‚úó .git/hooks directory not found');
      this.logWarning('  Git hooks cannot be installed without a valid Git repository.');
      return;
    }

    // Install pre-commit hook
    const preCommitHook = this.getPreCommitHookContent();
    const preCommitPath = path.join(gitHooksDir, 'pre-commit');
    fs.writeFileSync(preCommitPath, preCommitHook);
    fs.chmodSync(preCommitPath, '755');
    this.logSuccess('  ‚úÖ Installed pre-commit hook');

    // Install pre-push hook (Git Flow enforcement)
    const prePushHook = this.getPrePushHookContent();
    const prePushPath = path.join(gitHooksDir, 'pre-push');
    fs.writeFileSync(prePushPath, prePushHook);
    fs.chmodSync(prePushPath, '755');
    this.logSuccess('  ‚úÖ Installed pre-push hook (Git Flow enforcement)');
  }

  getPreCommitHookContent() {
    return `#!/bin/bash
# AST Intelligence Hooks - Pre-commit
# Auto-generated by pumuki-ast-hooks v${this.version}

# Check for bypass
if [[ -n "\${GIT_BYPASS_HOOK}" ]]; then
  echo "‚ö†Ô∏è  Bypassing AST hooks (GIT_BYPASS_HOOK=1)"
  exit 0
fi

# Change to project root (where package.json is)
cd "$(git rev-parse --show-toplevel)" || exit 1

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# GIT FLOW ENFORCEMENT: Block commits on protected branches
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "")

if [[ "$CURRENT_BRANCH" == "main" ]] || [[ "$CURRENT_BRANCH" == "master" ]] || [[ "$CURRENT_BRANCH" == "develop" ]]; then
  echo ""
  echo "‚ùå COMMIT BLOCKED: Cannot commit directly to protected branch: $CURRENT_BRANCH"
  echo ""
  echo "üêà Pumuki says: Create a feature branch first!"
  echo ""
  echo "   git checkout -b feature/my-feature"
  echo "   git checkout -b fix/my-fix"
  echo "   git checkout -b hotfix/urgent-fix"
  echo ""
  echo "Then run: npm run ast:gitflow"
  echo ""
  exit 1
fi

# Enforce Git Flow checks (strict) before allowing commit
ENFORCER_SCRIPT="scripts/hooks-system/infrastructure/shell/gitflow/gitflow-enforcer.sh"
if [[ ! -f "$ENFORCER_SCRIPT" ]]; then
  ENFORCER_SCRIPT="node_modules/pumuki-ast-hooks/scripts/hooks-system/infrastructure/shell/gitflow/gitflow-enforcer.sh"
fi

if [[ -f "$ENFORCER_SCRIPT" ]]; then
  echo ""
  echo "üîç Running Git Flow checks (strict)..."
  echo ""
  if ! GITFLOW_STRICT_CHECK=true bash "$ENFORCER_SCRIPT" check; then
    echo ""
    echo "üö® COMMIT BLOCKED: Git Flow checks failed"
    echo ""
    exit 1
  fi
fi

# Check if there are staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM 2>/dev/null | grep -E '\\.(ts|tsx|js|jsx|swift|kt)$' || true)
if [ -z "$STAGED_FILES" ]; then
  # No staged files to analyze, allow commit
  exit 0
fi

# Try node_modules/.bin first (works with npm install)
if [ -f "node_modules/.bin/ast-hooks" ]; then
  OUTPUT=$(node_modules/.bin/ast-hooks ast --staged 2>&1)
  EXIT_CODE=$?
  echo "$OUTPUT"
  if [ $EXIT_CODE -ne 0 ]; then
    exit $EXIT_CODE
  fi
  # Block commits only when there are actual CRITICAL/HIGH violations.
  # Source of truth is the AST SUMMARY LEVELS line.
  SUMMARY_LINE=$(echo "$OUTPUT" | grep -E "^AST SUMMARY LEVELS:" | tail -1)
  CRITICAL_COUNT=$(echo "$SUMMARY_LINE" | grep -oE "CRITICAL=[0-9]+" | head -1 | cut -d= -f2)
  HIGH_COUNT=$(echo "$SUMMARY_LINE" | grep -oE "HIGH=[0-9]+" | head -1 | cut -d= -f2)
  CRITICAL_COUNT=$(printf '%s' "$CRITICAL_COUNT" | tr -cd '0-9')
  HIGH_COUNT=$(printf '%s' "$HIGH_COUNT" | tr -cd '0-9')
  [ -z "$CRITICAL_COUNT" ] && CRITICAL_COUNT=0
  [ -z "$HIGH_COUNT" ] && HIGH_COUNT=0

  if [ "$CRITICAL_COUNT" -gt 0 ] || [ "$HIGH_COUNT" -gt 0 ]; then
    echo ""
    echo "‚ùå Commit blocked: Critical or High violations detected in staged files"
    
    TOTAL_VIOLATIONS=$((CRITICAL_COUNT + HIGH_COUNT))
    [ "$TOTAL_VIOLATIONS" -le 0 ] && TOTAL_VIOLATIONS=1
    
    osascript -e "display notification \\"Commit blocked by violations\\" with title \\"üö´ Commit Blocked\\" sound name \\"Basso\\"" 2>/dev/null || true
    
    exit 1
  fi
  # Copy ast-summary.json to root if it exists
  if [ -f ".audit_tmp/ast-summary.json" ]; then
    cp .audit_tmp/ast-summary.json ast-summary.json 2>/dev/null || true
  fi
  exit 0
fi

# Fallback: direct execution logic here...
echo "‚ö†Ô∏è  ast-intelligence-hooks not found"
exit 0
`;
  }

  getPrePushHookContent() {
    return `#!/bin/bash
# AST Intelligence Hooks - Pre-push (Git Flow Enforcement)
# Auto-generated by pumuki-ast-hooks v${this.version}

# Check for bypass
if [[ -n "\${GIT_BYPASS_HOOK}" ]]; then
  echo "‚ö†Ô∏è  Bypassing Git Flow enforcement (GIT_BYPASS_HOOK=1)"
  exit 0
fi

# Change to project root
cd "$(git rev-parse --show-toplevel)" || exit 1

# Check if we're pushing only tags (read from stdin)
while read local_ref local_sha remote_ref remote_sha; do
  # If pushing a tag (refs/tags/*), allow it
  if [[ "$local_ref" =~ ^refs/tags/ ]]; then
    echo ""
    echo "‚úÖ Tag push detected - allowing release workflow"
    echo ""
    exit 0
  fi
done

echo ""
echo "üîç Validating Git Flow compliance before push..."
echo ""

# Get current branch
CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "")

if [[ -z "$CURRENT_BRANCH" ]]; then
  echo "‚ùå Detached HEAD - cannot validate Git Flow"
  exit 1
fi

# Protected branches - cannot push directly
PROTECTED_BRANCHES=("main" "master" "develop")
for protected in "\${PROTECTED_BRANCHES[@]}"; do
  if [[ "$CURRENT_BRANCH" == "$protected" ]]; then
    echo "‚ùå Cannot push directly to protected branch: $CURRENT_BRANCH"
    echo ""
    echo "Create a feature branch instead:"
    echo "  git checkout -b feature/my-feature"
    echo ""
    exit 1
  fi
done

# Validate branch naming convention
if [[ ! "$CURRENT_BRANCH" =~ ^(feature|fix|hotfix|chore|docs|refactor|test|ci)/ ]]; then
  echo "‚ö†Ô∏è  Branch name '$CURRENT_BRANCH' doesn't follow Git Flow convention"
  echo ""
  echo "Expected patterns:"
  echo "  feature/description"
  echo "  fix/description"
  echo "  hotfix/description"
  echo "  chore/description"
  echo ""
  echo "This is a WARNING - push will continue"
  echo ""
fi

# Check evidence freshness (optional - warn only)
EVIDENCE_FILE=".AI_EVIDENCE.json"
if [[ -f "$EVIDENCE_FILE" ]]; then
  EVIDENCE_TS=$(jq -r '.timestamp // .severity_metrics.last_updated // empty' "$EVIDENCE_FILE" 2>/dev/null || echo "")
  if [[ -n "$EVIDENCE_TS" ]]; then
    # Parse timestamp and check age
    CLEAN_TS=$(echo "$EVIDENCE_TS" | sed 's/\\.[0-9]*Z$/Z/')
    EVIDENCE_EPOCH=$(date -j -f "%Y-%m-%dT%H:%M:%SZ" "$CLEAN_TS" +%s 2>/dev/null || echo "0")
    NOW_EPOCH=$(date +%s)
    AGE=$((NOW_EPOCH - EVIDENCE_EPOCH))
    
    if [[ $AGE -gt 300 ]]; then
      echo "‚ö†Ô∏è  Evidence is stale (\${AGE}s old, recommended <5min)"
      echo "   Consider running: npm run ast:refresh"
      echo ""
    fi
  fi
fi

# Run gitflow-enforcer if available (optional validation)
ENFORCER_SCRIPT="scripts/hooks-system/infrastructure/shell/gitflow/gitflow-enforcer.sh"
if [[ ! -f "$ENFORCER_SCRIPT" ]]; then
  ENFORCER_SCRIPT="node_modules/pumuki-ast-hooks/scripts/hooks-system/infrastructure/shell/gitflow/gitflow-enforcer.sh"
fi

if [[ -f "$ENFORCER_SCRIPT" ]]; then
  echo ""
  echo "üîç Running Git Flow checks (strict)..."
  echo ""
  if ! GITFLOW_STRICT_CHECK=true bash "$ENFORCER_SCRIPT" check; then
    echo ""
    echo "üö® PUSH BLOCKED: Git Flow checks failed"
    echo ""
    exit 1
  fi
fi

echo ""
echo "‚úÖ Git Flow validation passed. Proceeding with push..."
echo ""

exit 0
`;
  }

  logInfo(msg) { process.stdout.write(`${COLORS.cyan}${msg}${COLORS.reset}\n`); }
  logSuccess(msg) { process.stdout.write(`${COLORS.green}${msg}${COLORS.reset}\n`); }
  logWarning(msg) { process.stdout.write(`${COLORS.yellow}${msg}${COLORS.reset}\n`); }
  logError(msg) { process.stdout.write(`${COLORS.red}${msg}${COLORS.reset}\n`); }
}

module.exports = GitEnvironmentService;
