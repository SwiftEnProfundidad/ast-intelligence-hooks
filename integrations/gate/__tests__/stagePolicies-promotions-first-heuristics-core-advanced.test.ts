import test from 'node:test';
import {
  assert,
  astHeuristicsRuleSet,
  applyHeuristicSeverityForStage,
  evaluateGate,
  evaluateRules,
  policyForCI,
  policyForPreCommit,
  policyForPrePush,
} from './stagePoliciesFixtures';
test('gate promotes process.exit heuristic to blocking in PRE_COMMIT, PRE_PUSH y CI', () => {
  const processExitFact = {
    kind: 'Heuristic' as const,
    ruleId: 'heuristics.ts.process-exit.ast',
    severity: 'WARN' as const,
    code: 'HEURISTICS_PROCESS_EXIT_AST',
    message: 'AST heuristic detected process.exit usage.',
    filePath: 'apps/backend/src/main.ts',
  };

  const preCommitFindings = evaluateRules(
    applyHeuristicSeverityForStage(astHeuristicsRuleSet, 'PRE_COMMIT'),
    [processExitFact]
  );
  const preCommitDecision = evaluateGate([...preCommitFindings], policyForPreCommit());
  assert.equal(preCommitDecision.outcome, 'BLOCK');

  const prePushFindings = evaluateRules(
    applyHeuristicSeverityForStage(astHeuristicsRuleSet, 'PRE_PUSH'),
    [processExitFact]
  );
  const prePushDecision = evaluateGate([...prePushFindings], policyForPrePush());
  assert.equal(prePushDecision.outcome, 'BLOCK');

  const ciFindings = evaluateRules(
    applyHeuristicSeverityForStage(astHeuristicsRuleSet, 'CI'),
    [processExitFact]
  );
  const ciDecision = evaluateGate([...ciFindings], policyForCI());
  assert.equal(ciDecision.outcome, 'BLOCK');
});

test('gate promotes delete-operator heuristic to blocking in PRE_COMMIT, PRE_PUSH y CI', () => {
  const deleteOperatorFact = {
    kind: 'Heuristic' as const,
    ruleId: 'heuristics.ts.delete-operator.ast',
    severity: 'WARN' as const,
    code: 'HEURISTICS_DELETE_OPERATOR_AST',
    message: 'AST heuristic detected delete-operator usage.',
    filePath: 'apps/backend/src/main.ts',
  };

  const preCommitFindings = evaluateRules(
    applyHeuristicSeverityForStage(astHeuristicsRuleSet, 'PRE_COMMIT'),
    [deleteOperatorFact]
  );
  const preCommitDecision = evaluateGate([...preCommitFindings], policyForPreCommit());
  assert.equal(preCommitDecision.outcome, 'BLOCK');

  const prePushFindings = evaluateRules(
    applyHeuristicSeverityForStage(astHeuristicsRuleSet, 'PRE_PUSH'),
    [deleteOperatorFact]
  );
  const prePushDecision = evaluateGate([...prePushFindings], policyForPrePush());
  assert.equal(prePushDecision.outcome, 'BLOCK');

  const ciFindings = evaluateRules(
    applyHeuristicSeverityForStage(astHeuristicsRuleSet, 'CI'),
    [deleteOperatorFact]
  );
  const ciDecision = evaluateGate([...ciFindings], policyForCI());
  assert.equal(ciDecision.outcome, 'BLOCK');
});

test('gate promotes innerHTML heuristic to blocking in PRE_COMMIT, PRE_PUSH y CI', () => {
  const innerHtmlFact = {
    kind: 'Heuristic' as const,
    ruleId: 'heuristics.ts.inner-html.ast',
    severity: 'WARN' as const,
    code: 'HEURISTICS_INNER_HTML_AST',
    message: 'AST heuristic detected innerHTML assignment.',
    filePath: 'apps/frontend/src/main.tsx',
  };

  const preCommitFindings = evaluateRules(
    applyHeuristicSeverityForStage(astHeuristicsRuleSet, 'PRE_COMMIT'),
    [innerHtmlFact]
  );
  const preCommitDecision = evaluateGate([...preCommitFindings], policyForPreCommit());
  assert.equal(preCommitDecision.outcome, 'BLOCK');

  const prePushFindings = evaluateRules(
    applyHeuristicSeverityForStage(astHeuristicsRuleSet, 'PRE_PUSH'),
    [innerHtmlFact]
  );
  const prePushDecision = evaluateGate([...prePushFindings], policyForPrePush());
  assert.equal(prePushDecision.outcome, 'BLOCK');

  const ciFindings = evaluateRules(
    applyHeuristicSeverityForStage(astHeuristicsRuleSet, 'CI'),
    [innerHtmlFact]
  );
  const ciDecision = evaluateGate([...ciFindings], policyForCI());
  assert.equal(ciDecision.outcome, 'BLOCK');
});

test('gate promotes document.write heuristic to blocking in PRE_COMMIT, PRE_PUSH y CI', () => {
  const documentWriteFact = {
    kind: 'Heuristic' as const,
    ruleId: 'heuristics.ts.document-write.ast',
    severity: 'WARN' as const,
    code: 'HEURISTICS_DOCUMENT_WRITE_AST',
    message: 'AST heuristic detected document.write usage.',
    filePath: 'apps/frontend/src/main.tsx',
  };

  const preCommitFindings = evaluateRules(
    applyHeuristicSeverityForStage(astHeuristicsRuleSet, 'PRE_COMMIT'),
    [documentWriteFact]
  );
  const preCommitDecision = evaluateGate([...preCommitFindings], policyForPreCommit());
  assert.equal(preCommitDecision.outcome, 'BLOCK');

  const prePushFindings = evaluateRules(
    applyHeuristicSeverityForStage(astHeuristicsRuleSet, 'PRE_PUSH'),
    [documentWriteFact]
  );
  const prePushDecision = evaluateGate([...prePushFindings], policyForPrePush());
  assert.equal(prePushDecision.outcome, 'BLOCK');

  const ciFindings = evaluateRules(
    applyHeuristicSeverityForStage(astHeuristicsRuleSet, 'CI'),
    [documentWriteFact]
  );
  const ciDecision = evaluateGate([...ciFindings], policyForCI());
  assert.equal(ciDecision.outcome, 'BLOCK');
});

test('gate promotes insertAdjacentHTML heuristic to blocking in PRE_COMMIT, PRE_PUSH y CI', () => {
  const insertAdjacentHtmlFact = {
    kind: 'Heuristic' as const,
    ruleId: 'heuristics.ts.insert-adjacent-html.ast',
    severity: 'WARN' as const,
    code: 'HEURISTICS_INSERT_ADJACENT_HTML_AST',
    message: 'AST heuristic detected insertAdjacentHTML usage.',
    filePath: 'apps/frontend/src/main.tsx',
  };

  const preCommitFindings = evaluateRules(
    applyHeuristicSeverityForStage(astHeuristicsRuleSet, 'PRE_COMMIT'),
    [insertAdjacentHtmlFact]
  );
  const preCommitDecision = evaluateGate([...preCommitFindings], policyForPreCommit());
  assert.equal(preCommitDecision.outcome, 'BLOCK');

  const prePushFindings = evaluateRules(
    applyHeuristicSeverityForStage(astHeuristicsRuleSet, 'PRE_PUSH'),
    [insertAdjacentHtmlFact]
  );
  const prePushDecision = evaluateGate([...prePushFindings], policyForPrePush());
  assert.equal(prePushDecision.outcome, 'BLOCK');

  const ciFindings = evaluateRules(
    applyHeuristicSeverityForStage(astHeuristicsRuleSet, 'CI'),
    [insertAdjacentHtmlFact]
  );
  const ciDecision = evaluateGate([...ciFindings], policyForCI());
  assert.equal(ciDecision.outcome, 'BLOCK');
});

test('gate promotes child_process import heuristic to blocking in PRE_COMMIT, PRE_PUSH y CI', () => {
  const childProcessImportFact = {
    kind: 'Heuristic' as const,
    ruleId: 'heuristics.ts.child-process-import.ast',
    severity: 'WARN' as const,
    code: 'HEURISTICS_CHILD_PROCESS_IMPORT_AST',
    message: 'AST heuristic detected child_process import/require usage.',
    filePath: 'apps/backend/src/main.ts',
  };

  const preCommitFindings = evaluateRules(
    applyHeuristicSeverityForStage(astHeuristicsRuleSet, 'PRE_COMMIT'),
    [childProcessImportFact]
  );
  const preCommitDecision = evaluateGate([...preCommitFindings], policyForPreCommit());
  assert.equal(preCommitDecision.outcome, 'BLOCK');

  const prePushFindings = evaluateRules(
    applyHeuristicSeverityForStage(astHeuristicsRuleSet, 'PRE_PUSH'),
    [childProcessImportFact]
  );
  const prePushDecision = evaluateGate([...prePushFindings], policyForPrePush());
  assert.equal(prePushDecision.outcome, 'BLOCK');

  const ciFindings = evaluateRules(
    applyHeuristicSeverityForStage(astHeuristicsRuleSet, 'CI'),
    [childProcessImportFact]
  );
  const ciDecision = evaluateGate([...ciFindings], policyForCI());
  assert.equal(ciDecision.outcome, 'BLOCK');
});

test('gate promotes process.env mutation heuristic to blocking in PRE_COMMIT, PRE_PUSH y CI', () => {
  const processEnvMutationFact = {
    kind: 'Heuristic' as const,
    ruleId: 'heuristics.ts.process-env-mutation.ast',
    severity: 'WARN' as const,
    code: 'HEURISTICS_PROCESS_ENV_MUTATION_AST',
    message: 'AST heuristic detected process.env mutation.',
    filePath: 'apps/backend/src/main.ts',
  };

  const preCommitFindings = evaluateRules(
    applyHeuristicSeverityForStage(astHeuristicsRuleSet, 'PRE_COMMIT'),
    [processEnvMutationFact]
  );
  const preCommitDecision = evaluateGate([...preCommitFindings], policyForPreCommit());
  assert.equal(preCommitDecision.outcome, 'BLOCK');

  const prePushFindings = evaluateRules(
    applyHeuristicSeverityForStage(astHeuristicsRuleSet, 'PRE_PUSH'),
    [processEnvMutationFact]
  );
  const prePushDecision = evaluateGate([...prePushFindings], policyForPrePush());
  assert.equal(prePushDecision.outcome, 'BLOCK');

  const ciFindings = evaluateRules(
    applyHeuristicSeverityForStage(astHeuristicsRuleSet, 'CI'),
    [processEnvMutationFact]
  );
  const ciDecision = evaluateGate([...ciFindings], policyForCI());
  assert.equal(ciDecision.outcome, 'BLOCK');
});

test('gate promotes hardcoded secret/token heuristic to blocking in PRE_COMMIT, PRE_PUSH y CI', () => {
  const hardcodedSecretTokenFact = {
    kind: 'Heuristic' as const,
    ruleId: 'heuristics.ts.hardcoded-secret-token.ast',
    severity: 'WARN' as const,
    code: 'HEURISTICS_HARDCODED_SECRET_TOKEN_AST',
    message: 'AST heuristic detected hardcoded secret/token literal.',
    filePath: 'apps/backend/src/main.ts',
  };

  const preCommitFindings = evaluateRules(
    applyHeuristicSeverityForStage(astHeuristicsRuleSet, 'PRE_COMMIT'),
    [hardcodedSecretTokenFact]
  );
  const preCommitDecision = evaluateGate([...preCommitFindings], policyForPreCommit());
  assert.equal(preCommitDecision.outcome, 'BLOCK');

  const prePushFindings = evaluateRules(
    applyHeuristicSeverityForStage(astHeuristicsRuleSet, 'PRE_PUSH'),
    [hardcodedSecretTokenFact]
  );
  const prePushDecision = evaluateGate([...prePushFindings], policyForPrePush());
  assert.equal(prePushDecision.outcome, 'BLOCK');

  const ciFindings = evaluateRules(
    applyHeuristicSeverityForStage(astHeuristicsRuleSet, 'CI'),
    [hardcodedSecretTokenFact]
  );
  const ciDecision = evaluateGate([...ciFindings], policyForCI());
  assert.equal(ciDecision.outcome, 'BLOCK');
});

