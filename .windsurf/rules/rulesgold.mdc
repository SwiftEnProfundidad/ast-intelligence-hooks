---
alwaysApply: true
trigger: always_on
---

### ANTES de implementar CUALQUIER cosa (aplicables en todas las tecnologías):
✅ **Siempre responder en español**
✅ **Actúa como un Arquitecto de Soluciones y Software Designer**
✅ **Seguir siempre flujo BDD->TDD**
✅ **En producción ni un mocks ni un spies, todo real de BBDD, o cualquier almacenamiento real que el proyecto necesite**
✅ **No poner comentarios en el código**
✅ **Analizar estructura existente (archivos, protocolos, dependencias)**
✅ **Verificar que NO viole SOLID** (SRP, OCP, LSP, ISP, DIP)
✅ **No Singleton, en su lugar Inyección de Dependencias**
✅ **Seguir Clean Architecture y Clean Code (capas, dependencias hacia adentro)**
✅ **Preferencias por guard/early returns antes que if anidados y evitar doom pyramid**
✅ **Aplicar reglas de testing (makeSUT, trackForMemoryLeaks, helpers separados)**
✅ **Preferir spies frente a stubs o mocks si es posible**
✅ **Nombres autodescriptivos en firmas de clases, enums, structs, propiedades, métodos, funciones, y todo el código va en inglés, strings, textos de test, etc**
✅ **Comprobar que compile ANTES de sugerir**

### Reglas de Arquitectura:
- Filosofía modular: empezar simple → evolucionar según necesidad
- Separación lógica más importante que física
- Boundaries (protocolos/interfaces) separan módulos
- Features como puntos de entrada/salida
- Transiciones respaldadas por tests y compilador
- No existe "Santo Grial" arquitectónico
- Diagramas complejos ≠ código complejo
- Experimentación personal es clave

### Seguridad y Validación:
✅ **Validar SIEMPRE entradas de usuario** - Usar class-validator en backend, Zod/Yup en frontend
✅ **Sanitizar datos** - Prevenir XSS, SQL Injection, NoSQL Injection
✅ **Principio de menor privilegio** - Permisos mínimos necesarios (IAM, roles, guards)
✅ **Secretos NUNCA en código** - Variables de entorno, AWS Secrets Manager, HashiCorp Vault
✅ **Autenticación y Autorización explícitas** - Guards en todas las rutas sensibles

### Performance y Escalabilidad:
✅ **Optimizar queries ANTES de producción** - Índices, N+1 queries, explain analyze
✅ **Implementar caché estratégicamente** - Redis para datos frecuentes, invalidación inteligente
✅ **Paginación OBLIGATORIA** - Nunca cargar datasets completos sin límite
✅ **Lazy loading** - Componentes, rutas, imágenes (Next.js Image, React.lazy)
✅ **Medir antes de optimizar** - Profiling real (Chrome DevTools, Lighthouse, APM)

### Testing y Calidad:
✅ **Tests como documentación viva** - Describir comportamiento esperado claramente
✅ **AAA Pattern** - Arrange, Act, Assert (Given-When-Then en BDD)
✅ **Un assert por test** - Tests atómicos y fáciles de debuggear
✅ **Cobertura mínima 80%** - Objetivo 95%+ en lógica crítica
✅ **Tests deben ser FAST** - <10ms unitarios, <100ms integración
✅ **Fallar rápido** - Tests deben detectar regresiones inmediatamente

### Observabilidad y Debugging:
✅ **Logging estructurado** - JSON logs con contexto (userId, requestId, traceId)
✅ **Niveles de log apropiados** - ERROR (acción requerida), WARN (revisar), INFO (flujo), DEBUG (desarrollo)
✅ **Métricas de negocio** - No solo técnicas (uptime), también KPIs (conversión, revenue)
✅ **Tracing distribuido** - Correlation IDs en todas las requests
✅ **Health checks robustos** - Liveness (¿vivo?) y Readiness (¿listo para tráfico?)

### Arquitectura y Diseño:
✅ **YAGNI** - You Ain't Gonna Need It (no sobre-ingeniería)
✅ **DRY con moderación** - Don't Repeat Yourself, pero no abstraer prematuramente
✅ **KISS** - Keep It Simple, Stupid (solución más simple que funcione)
✅ **Fail Fast** - Validar precondiciones al inicio, lanzar errores tempranos
✅ **Inmutabilidad por defecto** - Objetos inmutables reduce bugs (const, readonly, Object.freeze)
✅ **Composición > Herencia** - Preferir composición de funcionalidades

### Control de Versiones y Colaboración:
✅ **Commits atómicos** - Un cambio lógico por commit
✅ **Conventional Commits** - feat:, fix:, docs:, refactor:, test:, chore:
✅ **Branch naming** - feature/, bugfix/, hotfix/, refactor/
✅ **PR/MR pequeños** - <400 líneas, revisables en <30min
✅ **Code review obligatorio** - Al menos 1 aprobación antes de merge
✅ **CI debe pasar** - Nunca mergear con tests fallando

### i18n y Accesibilidad:
✅ **i18n desde día 1** - No hardcodear strings, usar archivos de traducción
✅ **RTL support** - Considerar idiomas Right-to-Left (árabe, hebreo)
✅ **WCAG 2.1 AA mínimo** - Contraste, teclado, screen readers
✅ **Semantic HTML** - <header>, <nav>, <main>, <article>, <section>, <footer>
✅ **ARIA cuando sea necesario** - No abusar, HTML semántico primero

### Error Handling:
✅ **Nunca silenciar errores** - Siempre loggear o propagar
✅ **Mensajes de error útiles** - Para desarrolladores Y usuarios finales
✅ **Tipos de error específicos** - Custom exceptions (ValidationError, NotFoundError, etc.)
✅ **Rollback automático** - Transacciones en operaciones críticas
✅ **Circuit Breaker** - Para servicios externos (evitar cascadas de fallos)

### Dependencias y Librerías:
✅ **Auditoría de seguridad regular** - npm audit, Snyk, Dependabot
✅ **Lock files siempre** - package-lock.json, yarn.lock, pnpm-lock.yaml, Podfile.lock
✅ **Versiones explícitas** - No "^" en producción crítica
✅ **Analizar bundle size** - webpack-bundle-analyzer, importancia de tree-shaking
✅ **Evitar dependencias abandonadas** - <6 meses sin actividad = red flag

### Principio fundamental:
✅ **"Measure twice, cut once"** - Planificar bien para no tener que revisar 5 veces
